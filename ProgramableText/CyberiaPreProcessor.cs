using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace ProgramableText
{
    /// <summary>
    /// Supported Languages:
    /// Java
    /// C#
    /// SQL
    /// </summary>
    public class CyberiaPreProcessor
    {
        public String LanguageUsing { get; set; }

        public const String LANGUAGE_JAVA = "JAVA";
        public const String LANGUAGE_C_SHARP = "CSHARP";
        public const String LANGUAGE_SQL = "SQL";

        #region Directives

        public static List<String> DIRECTIVES = new List<String>();

        public static List<String> VARIABLE_MODS = new List<String>();

        public static List<String> VARIABLE_TYPES = new List<String>();

        public static List<String> VARIABLE_PREFIXES = new List<String>();

        public const String BLOCK_START = "blockstart";
        public const String BLOCK_END = "blockend";

        public const String DEV_ONLY = "devonly";

        public const String PROD_ONLY = "prodonly";

        public const String SQL_FLATFILE = "sql flatfile";

        public const String FOR_EACH_VARLIST = "foreach varlist";//This is a list of variable (start / end)

        /// <summary>
        /// This is going to be repeated for each variable in the var list with the VARNAME being replaced with the variable and
        /// NO_PREFIX_VARNAME being replaced with the variablename with the prefix being stripped.
        /// </summary>
        public const String FOR_EACH_CONTENT = "foreach content";

        static CyberiaPreProcessor()
        {
            DIRECTIVES.Add(DEV_ONLY);
            DIRECTIVES.Add(PROD_ONLY);

            VARIABLE_MODS.Add("public");
            VARIABLE_MODS.Add("private");
            VARIABLE_MODS.Add("protected");
            VARIABLE_MODS.Add("static");
            VARIABLE_MODS.Add("const");

            List<String> modValues = new List<string>();
            modValues.Add("a");//parameter
            modValues.Add("l");//local
            modValues.Add("i");//instance
            foreach (String modValue in modValues)
            {
                VARIABLE_PREFIXES.Add(modValue+"str");//string
                VARIABLE_PREFIXES.Add(modValue + "int");//int
                VARIABLE_PREFIXES.Add(modValue + "bol");//boolean
                VARIABLE_PREFIXES.Add(modValue + "col");//collection
                VARIABLE_PREFIXES.Add(modValue + "arr");//Array
                VARIABLE_PREFIXES.Add(modValue + "bus");//buisness class
                VARIABLE_PREFIXES.Add(modValue + "dt");//date time
                VARIABLE_PREFIXES.Add(modValue + "obj");//object

            }

            VARIABLE_TYPES.Add("integer");
            VARIABLE_TYPES.Add("string");
            VARIABLE_TYPES.Add("boolean");
            VARIABLE_TYPES.Add("long");
            VARIABLE_TYPES.Add("datetime");
        }

        /// <summary>
        /// Strips a variable name
        /// </summary>
        /// <param name="varNameLine"></param>
        /// <returns></returns>
        public String variableNameStripping(String varNameLine)
        {
            string rtrn = "";
            //TODO add SQL string capibility to var replacement
            //TODO don't replace var define with variable.
            String[] varSplit = varNameLine.Split(new String[] {" "}, StringSplitOptions.RemoveEmptyEntries);
            //remove public / private / protected

            foreach (string varPart in varSplit)
            {
                //contains?
                if (
                    !VARIABLE_MODS.Exists(x => x.Equals(varPart.ToLower()))
                    && !VARIABLE_TYPES.Exists(x => x.Equals(varPart.ToLower()))
                    && !varPart.Contains("<")// removes any variable types such as List<>
                    )
                {
                    rtrn = varPart.Replace(";", "");
                    
                }
            }

            return rtrn;
        }

        public String removePrefix(String varName)
        {
            String rtrn = varName;
            foreach (var prefix in VARIABLE_PREFIXES)
            {
                rtrn = rtrn.Replace(prefix, "");
            }
            return rtrn;
        }

        #endregion

        #region messages

        public string devMessage()
        {
            String devMessage = "This file was generated by the Cyberia Pre-Processor" + Environment.NewLine;
            devMessage += "Language of output file: " + LanguageUsing + Environment.NewLine;
            devMessage += "File Generated on: " + DateTime.Now + Environment.NewLine;

            return codeComment(devMessage);
        }

#endregion
        /// <summary>
        /// Processes input code (.cyberia files in the future)
        /// into devCode and prodCode
        /// </summary>
        /// <param name="input"></param>
        /// <param name="devCode"></param>
        /// <param name="prodCode"></param>
        public void processText(String input, out String devCode, out String prodCode)
        {
            string scratchpad = input;
            devCode = "" + devMessage();
            prodCode = "" + devMessage();

            //line by line pre-processing
            String devByLines, prodByLines;

            foreach (String block in getBlocksForDirective(input, SQL_FLATFILE))
            {
                scratchpad = sqlFlatFile(scratchpad, block);
            }
            
            

            lineByLinePreProcess(scratchpad, out devByLines, out prodByLines);

            devCode += scratchpad;
            prodCode += prodByLines;
        }

        protected void lineByLinePreProcess(string input, out string devByLines, out string prodByLines)
        {
            devByLines = "";
            prodByLines = "";

            String[] lines = input.Split(new[] { "\r\n", "\r", "\n" },
                StringSplitOptions.None);

            foreach (String line in lines)
            {
                //find any pre-processor directives? do those
                List<String> directives = findDirectives(line);
                //DEV / Prod only
                if (directives.Count >= 1)
                {


                    if (directives.Contains(DEV_ONLY))
                    {
                        devByLines += line + Environment.NewLine;

                    }
                    else if (directives.Contains(PROD_ONLY))
                    {
                        prodByLines += line + Environment.NewLine;
                    }
                }
                else
                {
                    //No Processor directives found
                    devByLines += line + Environment.NewLine;
                    prodByLines += line + Environment.NewLine;
                }


            }

        }

        public static readonly string[] NEW_LINE_SPLIT = new[] { "\r\n", "\r", "\n" };

        #region SQL Specific funtions

        /// <summary>
        /// Returns the result of 
        /// </summary>
        /// <param name="block"></param>
        /// <returns></returns>
        public string sqlFlatFile(string fullText,string block)
        {
            //remove variables

            string varname = getSimpleVarValue("var", block);
            string tables = getSimpleVarValue("tables", block);
            string order = getSimpleVarValue("order", block);
            //parse acutal code

            String sqlQuery = "Select Concat(";

            List<String> onlySqlVars = block.Split(NEW_LINE_SPLIT, StringSplitOptions.RemoveEmptyEntries).Where(x => x.Contains(",")).ToList();

            List<String> allOutputVars = new List<string>();

            foreach (String sqlVarLine in onlySqlVars)
            {
                //split by commas
                //first two are always the same, anything else is an operation that should be performed
                String[] commaStrings = sqlVarLine.Split(',');

                if (commaStrings.Length >= 2)
                {
                    string varName = commaStrings[0];
                    int length = int.Parse(commaStrings[1]);
                    string padCharacters = "' '";//defaults to space
                    string usedVarName = varName;
                    Boolean rightPad = true;

                    usedVarName = "isnull(" + usedVarName + ",''" + ")"; //default add isNull

                    if (commaStrings.Length > 2)
                    {
                        
                        for (int i = 2; i < commaStrings.Length; i++)
                        {
                            string extraCommand = commaStrings[i];
                            if (extraCommand.Contains("remove"))
                            {
                                List<String> args = parseFunction("remove",extraCommand);
                                //remove these characters from the text pulled by sql
                                foreach (String arg in args)
                                {
                                    usedVarName = "replace(" + usedVarName + ",\'" + arg + "\',\'\')";
                                }
                                
                            }
                            if (extraCommand.Contains("pad"))
                            {
                                List<String> args = parseFunction("pad", extraCommand);
                                padCharacters = args[0];
                            }
                            if (extraCommand.Contains("leftPad"))
                            {
                                rightPad = false;
                            }
                        }
                     }//end of special conditions
                       
                        

                        //run the variables through the process of padding
                        //TODO a bunch of cool SQL generation utilities
                        string padVarOutput = "replicate(" + padCharacters + "," + length + " - Len("+usedVarName+"))";
                        string actualVarOutput = usedVarName;
                    if (rightPad)
                    {
                        allOutputVars.Add(actualVarOutput);
                        allOutputVars.Add(padVarOutput);
                    }
                    else
                    {
                        allOutputVars.Add(padVarOutput);
                        allOutputVars.Add(actualVarOutput);
                        
                    }
                    //replicate args
                }


            }//end foreach

            sqlQuery += allOutputVars.Aggregate((i, j) => i + "," + j);

            sqlQuery += ")";//END of select
            if (tables.Length >= 1)
                sqlQuery += " FROM " + tables;
            if (order.Length>=1)
            sqlQuery += " ORDER BY " + order;


            fullText = varReplace(fullText,varname,sqlQuery);

            return fullText;
        }

        private List<string> parseFunction(string functionName, string str)
        {
            str = str.Replace(functionName+"(", "").Replace(")", "");
            return str.Split('|').ToList();
        }

        private string getSimpleVarValue(string var, string block)
        {
            if (block.Contains(var))
            {
                Regex findVarNameRegex = new Regex( "(" + var + "[^\\n]+)");
                Match m = findVarNameRegex.Match(block);
                Group g = m.Groups[0];
                String varName = g.ToString();
                varName = varName.Trim();
                varName = varName.Remove(0, var.Length);
                varName = varName.Trim();
                return varName;
            }
            else
            {
                return "";
            }
        }

        public static string varReplace(string fullText, String varName, String replaceWith)
        {
            return fullText.Replace(varName, replaceWith);
        }

        #endregion

        /// <summary>
        /// NESTING NOT SUPPORTED
        /// </summary>
        /// <param name="directive"></param>
        /// <returns></returns>
        public List<String> getBlocksForDirective(String str,String directive)
        {
            List<String> blocks = new List<string>();
            String directiveStart = directive +" " + BLOCK_START;
            String directiveEnd = directive +" "+ BLOCK_END;

            string[] splitOnDirectives = str.Split(new [] {directiveStart},StringSplitOptions.None);

            foreach (String block in splitOnDirectives.Where(x=>x.Contains(directiveEnd)))
            {
                String parsedBlock = block.Remove(block.IndexOf(directiveEnd, 0));
                blocks.Add(parsedBlock);
            }

            return blocks;

        }

        public List<string> findDirectives(string str)
        {
            List<String> directivesFound = new List<string>();
            foreach (String directive in DIRECTIVES)
            {
                if (findDirective(str,directive))
                {
                    directivesFound.Add(directive);
                }
            }

            return directivesFound;
        }

        public bool findDirective(string str, string directive)
        {
            if (str.ToLower().Contains(directive))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public String codeComment(String strToComment)
        {
            return "/*" + Environment.NewLine + strToComment + Environment.NewLine + "*/" + Environment.NewLine;
        }
        public String codeCommentLine(String strToComment)
        {
            if (LanguageUsing.Equals(LANGUAGE_SQL))
            {
                //SQL support
                return "--" + strToComment;
            }
            else
            {
                //Java / C# support
                return "//" + strToComment;
            }
        }
    }
}
